"use strict";(self.webpackChunkocap=self.webpackChunkocap||[]).push([[5289],{"./node_modules/langchain/dist/chains/sequential_chain.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{SequentialChain:()=>SequentialChain,SimpleSequentialChain:()=>SimpleSequentialChain});var asyncToGenerator=__webpack_require__("./node_modules/@angular-devkit/build-angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"),base=__webpack_require__("./node_modules/langchain/dist/chains/base.js");function intersection(setA,setB){const _intersection=new Set;for(const elem of setB)setA.has(elem)&&_intersection.add(elem);return _intersection}function difference(setA,setB){const _difference=new Set(setA);for(const elem of setB)_difference.delete(elem);return _difference}function formatSet(input){return Array.from(input).map((i=>`"${i}"`)).join(", ")}class SequentialChain extends base.l{static lc_name(){return"SequentialChain"}get inputKeys(){return this.inputVariables}get outputKeys(){return this.outputVariables}constructor(fields){if(super(fields),Object.defineProperty(this,"chains",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"outputVariables",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"returnAll",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.chains=fields.chains,this.inputVariables=fields.inputVariables,this.outputVariables=fields.outputVariables??[],this.outputVariables.length>0&&fields.returnAll)throw new Error("Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.");this.returnAll=fields.returnAll??!1,this._validateChains()}_validateChains(){if(0===this.chains.length)throw new Error("Sequential chain must have at least one chain.");const memoryKeys=this.memory?.memoryKeys??[],inputKeysSet=new Set(this.inputKeys),memoryKeysSet=new Set(memoryKeys),keysIntersection=intersection(inputKeysSet,memoryKeysSet);if(keysIntersection.size>0)throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);const availableKeys=function union(setA,setB){const _union=new Set(setA);for(const elem of setB)_union.add(elem);return _union}(inputKeysSet,memoryKeysSet);for(const chain of this.chains){let missingKeys=difference(new Set(chain.inputKeys),availableKeys);if(chain.memory&&(missingKeys=difference(missingKeys,new Set(chain.memory.memoryKeys))),missingKeys.size>0)throw new Error(`Missing variables for chain "${chain._chainType()}": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);const outputKeysSet=new Set(chain.outputKeys),overlappingOutputKeys=intersection(availableKeys,outputKeysSet);if(overlappingOutputKeys.size>0)throw new Error(`The following output variables for chain "${chain._chainType()}" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);for(const outputKey of outputKeysSet)availableKeys.add(outputKey)}if(0===this.outputVariables.length)if(this.returnAll){const outputKeys=difference(availableKeys,inputKeysSet);this.outputVariables=Array.from(outputKeys)}else this.outputVariables=this.chains[this.chains.length-1].outputKeys;else{const missingKeys=difference(new Set(this.outputVariables),new Set(availableKeys));if(missingKeys.size>0)throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`)}}_call(values,runManager){var _this=this;return(0,asyncToGenerator.Z)((function*(){let input={};const allChainValues=values;let i=0;for(const chain of _this.chains){i+=1,input=yield chain.call(allChainValues,runManager?.getChild(`step_${i}`));for(const key of Object.keys(input))allChainValues[key]=input[key]}const output={};for(const key of _this.outputVariables)output[key]=allChainValues[key];return output}))()}_chainType(){return"sequential_chain"}static deserialize(data){return(0,asyncToGenerator.Z)((function*(){const chains=[],inputVariables=data.input_variables,outputVariables=data.output_variables,serializedChains=data.chains;for(const serializedChain of serializedChains){const deserializedChain=yield base.l.deserialize(serializedChain);chains.push(deserializedChain)}return new SequentialChain({chains,inputVariables,outputVariables})}))()}serialize(){const chains=[];for(const chain of this.chains)chains.push(chain.serialize());return{_type:this._chainType(),input_variables:this.inputVariables,output_variables:this.outputVariables,chains}}}class SimpleSequentialChain extends base.l{static lc_name(){return"SimpleSequentialChain"}get inputKeys(){return[this.inputKey]}get outputKeys(){return[this.outputKey]}constructor(fields){super(fields),Object.defineProperty(this,"chains",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"inputKey",{enumerable:!0,configurable:!0,writable:!0,value:"input"}),Object.defineProperty(this,"outputKey",{enumerable:!0,configurable:!0,writable:!0,value:"output"}),Object.defineProperty(this,"trimOutputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.chains=fields.chains,this.trimOutputs=fields.trimOutputs??!1,this._validateChains()}_validateChains(){for(const chain of this.chains){if(1!==chain.inputKeys.filter((k=>!chain.memory?.memoryKeys.includes(k)??!0)).length)throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);if(1!==chain.outputKeys.length)throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`)}}_call(values,runManager){var _this2=this;return(0,asyncToGenerator.Z)((function*(){let input=values[_this2.inputKey],i=0;for(const chain of _this2.chains)i+=1,input=(yield chain.call({[chain.inputKeys[0]]:input,signal:values.signal},runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]],_this2.trimOutputs&&(input=input.trim()),yield runManager?.handleText(input);return{[_this2.outputKey]:input}}))()}_chainType(){return"simple_sequential_chain"}static deserialize(data){return(0,asyncToGenerator.Z)((function*(){const chains=[],serializedChains=data.chains;for(const serializedChain of serializedChains){const deserializedChain=yield base.l.deserialize(serializedChain);chains.push(deserializedChain)}return new SimpleSequentialChain({chains})}))()}serialize(){const chains=[];for(const chain of this.chains)chains.push(chain.serialize());return{_type:this._chainType(),chains}}}}}]);